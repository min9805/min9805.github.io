---
title: "[BOJ][Java] ë°±ì¤€ 13418 ë²ˆ: í•™êµ íƒë°©í•˜ê¸°"
excerpt: "[BOJ][Java] ë°±ì¤€ 13418 ë²ˆ: í•™êµ íƒë°©í•˜ê¸°"

categories:
  - ps
tags:
  - [ë°±ì¤€, BOJ]

toc: true
toc_sticky: true

date: 2024-04-09
last_modified_at: 2024-04-09
---

> 1ì¼ 1PS 87ì¼ì°¨!

# ğŸ“š ë¬¸ì œ

---

> [ê³¨ë“œ 3] -
> [í•™êµ íƒë°©í•˜ê¸°](https://www.acmicpc.net/problem/13418)

# ğŸ’¡ í’€ì´ ê³¼ì •

---

- MST(ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬) ë¬¸ì œì´ë‹¤. 
- Java ë¥¼ í’€ ë•ŒëŠ” Node ë¼ëŠ” í´ë˜ìŠ¤ë¥¼ ì¶”ê°€í•œë‹¤. 
- ê°„ì„ ì„ ëª¨ë‘ ì¶”ê°€í•˜ê³  ìµœëŒ€, ìµœì†Œë¡œ sort í•˜ê¸° ë³´ë‹¤ëŠ” Heap ì„ ì‚¬ìš©í•´ ì •ë ¬ì„ ëŒ€ì‹ í•œë‹¤.
- MST ì‹œ ì‚¬ì´í´ ì¡´ì¬ ì—¬ë¶€ëŠ” Union-Find ë¥¼ í†µí•´ ê²€ì¦í•´ë‚¸ë‹¤.


# ğŸ“Œí¬ì¸íŠ¸

---

- parent
    - Union-Find ë¥¼ ë‘ ë²ˆ ì‚¬ìš©í•˜ê¸°ì— ê¼­ ì´ˆê¸°í™” í•´ì¤˜ì•¼í•œë‹¤. 
- class Node
    - Node ë¼ëŠ” í´ë˜ìŠ¤ë¥¼ ìƒì„±í•´ ì‚¬ìš©í•˜ë©´ ì¢‹ë‹¤.

# ğŸ’» ì½”ë“œ

---

{% raw %}

```

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    private static Queue<Node> minHeap = new PriorityQueue<>();
    private static Queue<Node> maxHeap = new PriorityQueue<>((v1, v2) -> v2.weight - v1.weight);
    static class Node implements Comparable<Node> {
        int v1, v2, weight;

        public Node(int v1, int v2, int weight) {
            this.v1 = v1;
            this.v2 = v2;
            this.weight = weight;
        }

        @Override
        public int compareTo(Node o) {
            return weight - o.weight;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        //Graph ìƒì„±
        // ë‚´ë¦¬ë§‰ê¸¸ ê°€ì¤‘ì¹˜ëŠ” 1, ì˜¤ë¥´ë§‰ê¸¸ ê°€ì¤‘ì¹˜ëŠ” K^2
        for (int i = 0; i < M + 1; i++) {
            // ì…êµ¬ì™€ 1ë²ˆ ì •ì ê°„ì˜ ê´€ê³„ê°€ ê°€ì¥ ë¨¼ì € ì£¼ì–´ì§„ë‹¤.
            st = new StringTokenizer(br.readLine());
            int v1 = Integer.parseInt(st.nextToken());
            int v2 = Integer.parseInt(st.nextToken());
            int weight = Integer.parseInt(st.nextToken());

            minHeap.add(new Node(v1, v2, weight));
            maxHeap.add(new Node(v1, v2, weight));
        }

        //ìµœì†Œ í”¼ë¡œë„ ê³„ì‚° MST
        int[] parent = new int[N + 1];
        for (int i = 0; i <= N; i++){
            parent[i] = i;
        }

        int cnt = 0;
        int maxCost = 0;
        while((cnt <= N) && !minHeap.isEmpty()){
            Node node = minHeap.poll();
            int v1 = node.v1;
            int v2 = node.v2;
            int weight = node.weight;

            if (find(parent, v1) != find(parent, v2)){
                union(parent, v1, v2);
                cnt++;
                if(weight == 0){
                    maxCost += 1;
                }
            }
        }

        for (int i = 0; i <= N; i++){
            parent[i] = i;
        }

        cnt = 0;
        int minCost = 0;
        while((cnt <= N) && !maxHeap.isEmpty()){
            Node node = maxHeap.poll();
            int v1 = node.v1;
            int v2 = node.v2;
            int weight = node.weight;

            if (find(parent, v1) != find(parent, v2)){
                union(parent, v1, v2);
                cnt++;
                if(weight == 0){
                    minCost += 1;
                }
            }
        }

        int answer = (int) Math.pow(maxCost, 2) - (int) Math.pow(minCost, 2);
        System.out.println(answer);
    }

    public static int find(int[] parent, int x){
        if (parent[x] == x){
            return x;
        }
        return parent[x] = find(parent, parent[x]);
    }
    public static void union(int[] parent, int x, int y){
        x = find(parent, x);
        y = find(parent, y);

        if (x != y){
            parent[y] = x;
        }
    }
}


```

{% endraw %}
