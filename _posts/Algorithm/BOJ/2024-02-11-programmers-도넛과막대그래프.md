---
title: "[Programmers][Python] í”„ë¡œê·¸ëž˜ë¨¸ìŠ¤ 2024 KAKAO WINTER INTERNSHIP: ë„ë„›ê³¼ ë§‰ëŒ€ ê·¸ëž˜í”„"
excerpt: "[Programmers][Python] í”„ë¡œê·¸ëž˜ë¨¸ìŠ¤ 2024 KAKAO WINTER INTERNSHIP: ë„ë„›ê³¼ ë§‰ëŒ€ ê·¸ëž˜í”„"

categories:
  - ps
tags:
  - [í”„ë¡œê·¸ëž˜ë¨¸ìŠ¤, programmers]

toc: true
toc_sticky: true

date: 2024-02-11
last_modified_at: 2024-02-14
---

> 1ì¼ 1PS 49ì¼ì°¨!

# ðŸ“š ë¬¸ì œ

---

> Level 2

# ðŸ’¡ í’€ì´ ê³¼ì •

---

- ê°„ì„ ë“¤ì„ ì¼ë‹¨ ëª¨ë‘ dictionary ì— ì €ìž¥í•œë‹¤.
- ë§Œì•½ í•œ ì •ì ì—ì„œ ë»—ì–´ë‚˜ê°€ëŠ” ê°„ì„ ì˜ ê°œìˆ˜ê°€ 3ê°œ ì´ìƒì´ë¼ë©´ í•´ë‹¹ ì •ì ì´ ë¬´ì¡°ê±´ ìƒì„±ëœ ì •ì ì´ë‹¤!
    - ì´ëŠ” ì¼ë°˜ì ì¸ ë„ë„›, ë§‰ëŒ€, 8ìž ëª¨ì–‘ì˜ ê·¸ëž˜í”„ ì¤‘ì—ì„œ ì–´ë–¤ ì •ì ë“¤ë„ 3ê°œ ì´ìƒì˜ ì¶œë°œ ê°„ì„ ì„ ê°€ì§€ì§€ ëª»í•œë‹¤ëŠ” ê²ƒì´ë‹¤.
    - 3ê°œ ì´ìƒì˜ "ì¶œë°œ" ê°„ì„ ì„ ê°€ì§€ì§€ ëª»í•¨ì— ì£¼ì˜í•˜ìž. "ë„ì°©" ê°„ì„ ì€ 3ê°œ ì´ìƒ ê°€ì§ˆ ìˆ˜ ìžˆë‹¤.

- ë˜í•œ í•œ ì •ì ì—ì„œ ì•„ëž˜ì™€ ê°™ì€ ê¸°ì¤€ìœ¼ë¡œ ê·¸ëž˜í”„ë¥¼ íŒë‹¨í•  ìˆ˜ ìžˆë‹¤.
    - ë§‰ëŒ€ ëª¨ì–‘ ê·¸ëž˜í”„
        - í•œ ì •ì ì—ì„œ ë‹¤ìŒ ì •ì ìœ¼ë¡œ ê³„ì†í•´ì„œ ì´ë™í•  ë•Œ ë” ì´ìƒ ì´ë™í•  ìˆ˜ ì—†ëŠ” ì •ì ì´ ì¡´ìž¬í•œë‹¤ë©´ ë§‰ëŒ€ ëª¨ì–‘ì´ë‹¤.
    - 8ìž ëª¨ì–‘ ê·¸ëž˜í”„
        - í•œ ì •ì ì—ì„œ ë‹¤ìŒ ì •ì ìœ¼ë¡œ ê³„ì†í•´ì„œ ì´ë™ ì¤‘ ì¶œë°œ ê°„ì„ ì˜ ê°œìˆ˜ê°€ 2ê°œê°€ ì¡´ìž¬í•œë‹¤ë©´ í•´ë‹¹ ê·¸ëž˜í”„ëŠ” 8ìž ëª¨ì–‘ì´ë‹¤.
    - ë„ë„› ëª¨ì–‘ ê·¸ëž˜í”„
        - í•œ ì •ì ì—ì„œ ë‹¤ìŒ ì •ì ìœ¼ë¡œ ê³„ì†í•´ì„œ ì´ë™ ì¤‘ ì¶œë°œ ê°„ì„ ì˜ ê°œìˆ˜ê°€ 2ê°œì¸ ì ì´ ì—†ê³  ì¶œë°œì ìœ¼ë¡œ ë˜ëŒì•„ì˜¨ë‹¤ë©´ ë„ë„› ëª¨ì–‘ì´ë‹¤.

- ë§Œì•½ ìƒì„±ëœ ì •ì ì´ íŠ¹ì •ëœë‹¤ë©´ í•´ë‹¹ ì •ì ì—ì„œ ë»—ì–´ë‚˜ê°€ëŠ” ì •ì ë“¤ì´ ì–´ë–¤ ìœ í˜•ì¸ì§€ë§Œ íŒŒì•…í•˜ë©´ ëœë‹¤. 
    - ë»—ì–´ë‚˜ê°€ëŠ” ì •ì ë“¤ì„ ìœ„ ê¸°ì¤€ì— ë§žì¶° íŒŒì•…í•œë‹¤.
- ë§Œì•½ ìƒì„±ëœ ì •ì ì´ íŠ¹ì •ë˜ì§€ ì•ŠëŠ”ë‹¤ë©´ "ì¶œë°œ" ê°„ì„ ì´ ì¡´ìž¬í•˜ëŠ” ì •ì ë“¤ì„ giver ê·¸ë£¹ì— ë„£ì–´ í•´ë‹¹ ê·¸ë£¹ì•ˆì— ì •ì ë“¤ì„ ëŒ€ìƒìœ¼ë¡œ ì¡°ì‚¬í•œë‹¤.
    - ë™ì¼í•˜ê²Œ í•´ë‹¹ ì •ì ë“¤ì„ ê¸°ì¤€ìœ¼ë¡œ ë»—ì–´ë‚˜ê°€ëŠ” ì •ì ë“¤ì— ëŒ€í•´ ìœ„ ê¸°ì¤€ì— ë§žì¶° íŒŒì•…í•œë‹¤.
    - ì´ë•Œ ë°©ë¬¸ ì—¬ë¶€ë¥¼ ê¸°ë¡í•´ë†“ëŠ”ë‹¤.
    - ëª¨ë“  íŒŒì•…ì´ ëë‚¬ìœ¼ë©´ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œê°€ ì „ë¶€ ë§‰ëŒ€ ëª¨ì–‘ì˜ ë…¸ë“œë¼ë©´ í•´ë‹¹ ì •ì ì´ ìƒì„±ëœ ì •ì ì´ë‹¤.
        - ëª¨ë“  ê·¸ëž˜í”„ì— ì ‘ì´‰í•˜ì˜€ê³  ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œëŠ” ë§‰ëŒ€ ê·¸ëž˜í”„ì˜ ì•žìª½ ë…¸ë“œì˜€ì„ ë¿ì´ë‹¤.
        - ë§Œì•½ ë§‰ëŒ€ ê·¸ëž˜í”„ê°€ ì•„ë‹Œ ë‹¤ë¥¸ ëª¨ì–‘ì˜ ê·¸ëž˜í”„ë¼ë©´ í•´ë‹¹ ì •ì ì—ì„œ í•´ë‹¹ ê·¸ëž˜í”„ë¡œ ì—°ê²°ë˜ëŠ” ì¶œë°œ ê°„ì„ ì´ ì¡´ìž¬í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ëœ»ì´ë¯€ë¡œ ìƒì„±ëœ ì •ì ì´ ì•„ë‹ˆë‹¤!


# ðŸ“Œí¬ì¸íŠ¸

---

- ì‹¤ì œ ì‹œí—˜ì„ ë³´ì•˜ì„ ë•Œ ì •ë‹µì²˜ë¦¬ ë˜ì—ˆì§€ë§Œ ì´í›„ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ê°€ ì¶”ê°€ë˜ìž ì˜¤ë‹µì´ ë˜ì—ˆë‹¤.
    - ì´ëŠ” ë°©ë¬¸í•˜ì§€ ì•ŠëŠ” ë…¸ë“œê°€ ë§‰ëŒ€ ëª¨ì–‘ì¸ì§€ íŒŒì•…í•˜ëŠ” ë¶€ë¶„ì—ì„œ ë“¤ì—¬ì“°ê¸°ê°€ ìž˜ëª»ë˜ì–´ìžˆì–´ì„œ ê·¸ëŸ° ê²ƒ ê°™ë‹¤. 

# ðŸ’» ì½”ë“œ

---

{% raw %}

```

def solution(edges):
    answer = [0, 0, 0, 0]
    dic = {}
    give = set()

    for edge in edges:
        if edge[0] in dic:
            dic[edge[0]].append(edge[1])
        else:
            dic[edge[0]] = [edge[1]]
        give.add(edge[1])

    giver = []
    for g in dic:
        if g not in give:
            giver.append(g)

    max_key = max(dic, key=lambda k: len(dic[k]))

    if len(dic[max_key]) >= 3:
        answer[0] = max_key
        for start in dic[max_key]:
            if start not in dic:
                answer[2] += 1
                continue
            next_node = dic[start][0]

            while True:
                if next_node not in dic:
                    answer[2] += 1
                    break
                elif len(dic[next_node]) == 2:
                    answer[3] += 1
                    break
                elif next_node == start:
                    answer[1] += 1
                    break
                next_node = dic[next_node][0]
    else:
        for g in giver:
            answer = [0, 0, 0, 0]
            visited = [False] * (len(give) + len(giver) + 1)
            visited[0] = True
            visited[g] = True

            for start in dic[g]:
                print(start)
                visited[start] = True
                if start not in dic:
                    answer[2] += 1
                    continue
                next_node = dic[start][0]
                visited[next_node] = True

                while True:
                    if next_node not in dic:
                        answer[2] += 1
                        break
                    elif len(dic[next_node]) == 2:
                        answer[3] += 1
                        break
                    elif next_node == start:
                        answer[1] += 1
                        break
                    next_node = dic[next_node][0]

            for index, tf in enumerate(visited):
                if tf == False and len(dic[index]) == 1:
                    answer[0] = g
                    return answer


    return answer
    
```

{% endraw %}
